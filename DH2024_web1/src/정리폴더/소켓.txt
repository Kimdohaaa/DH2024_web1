* HTTP :  이동 문자 전송 규약 (소켓 존재 X) *

[WS (Web Socket)] (소켓 존재 O)
- 정의 : WS 프로토콜을 기반으로 클라이언트와 서버 사이에 지속적인 양방향 연결을 이용한 통신 프로토콜
 * 지속적인 양방향 연결 => 상태 유지 / 저장 O
 * HTTP 는 무상태 => 저장 X
    -> 클라이언트가 request 하고 서버가 response 하는 구조 
 	-> 한번 request / response 한 값은 저장되지 않음) 
 	-> request 가 있어야지만 response 가능 
 	-> 주 사용처 
 		1) HTML 통신 (웹페이지)
 		2) REST 통신 (자료)

- 특징
  1) 클라이언트가 서버로부터 연결 신청
  2) 연결된 상태를 유지하고 지속적인 양방향 통신 요청 구조

- 구조 (클라이언트 소켓과 서버 소켓 존재)
   <클라이언트 소켓>  ----->  <서버 소켓> => 클라이언트 소켓 바인딩
   1. 클라이언트 소켓 -연결요청-> 서버 소켓
   2. 서버 소켓이 클라이언트 소켓의 요청을 바인딩(등록)	
   
   <클라이언트 소켓>  ----->  <서버 소켓>
   1. 서버 소켓에 바인딩된(상태유지된) 클라이언트 소켓 -메세지전송-> 서버소켓
   2. 서버 소켓이 클라이언트 소켓으로부터 메세지를 받아 로직(기능) 처리
   
   <클라이언트 소켓>  <-----  <서버 소켓>
   1. 서버 소켓에 등록된(상태유지된) 서버 소켓 -메세지전송-> 클라이언트 소켓
   2. 클라이언트 소켓이 서버소켓으로부터 메세지를 맞아 로직(기능) 처리
 
- 사용처
   1. 실시간 양방향 통신
   	  1) 채팅
   	  2) 양방향 통신
   2. 보안  
   
[소켓]
- 소켓(=EndPoint) : 통신의 종착점 (통신을 주고 받을 때 도착 지점)
   -> 클라이언트 소켓이 서버 소켓으로 부터 최초 연결 요청
★ WebSocket 과 fetch 는 비동식 통신 ★

[동기식 통신 vs 비동기식 통신]
1. 동기식 통신
	-> Request 후 다음 요청을 받지 않고 대기상태로 들어가 서버의 Response 를 받은 후 다음 코드흐름 진행 
2. 비동기식 통신
	-> Request 후 서버의 Response 를 기다리지 않고 다음 코드흐름 진행
	예] fetch / Socket
   
[WS 라이브러리]
- 종류
	1. Servlet 내장 라이브러리  => 서버 소켓
		[클라이언트 소켓 -접속-> 서버소켓]
			1) WebSocket 으로 사용할 클래스 생성
				<메소드>
					1) @OnOpen    : 클라이언트 소켓이 접속 시 로직 구현
						public void onOpen(Session session){실행 코드}
					2) @OnMessage : 클라이언트 소켓이 메세지 전송 시 로직 구현
						public vodi onMessage (Session sessioin, String message){실행 코드}
					3) @OnClose   : 클라이언트 소켓과 연결 종료 시 로직 구현
						public void onOpen(Session session){실행 코드}
					4) @OnError   : 클라이언트 소켓과 예러 발생 시 실행 로직
						public void onOpen(Session session){실행 코드}
					
			2) @ServerEndpoint("/서버소켓명") 어노테이션을 통해 서버 소켓 주소 생성
			
			3) 메소드 위에 @OnOpen 어노테이션을 통해 클라이언트 소켓이 서버 소켓에 접속 했을 때 로직 구현
		
		[클라이언트 소켓 -메세지전송-> 서버 소켓]
			- 메소드 위에 @OnMessage 어노테이션을 통해 클라이언트 소켓이 보낸 메세지 확인
		
		[클라이언트 소켓 <-메세지전송- 서버 소켓]
			- session.getBasicRemote().sendText("클라이언트 소켓에게 보낼 메세지(문자열)");
	
		[클라이언트 소켓 접속 종료] => 접속 종료 : 클라이언트 소켓이 포함된 JS 새로고침 시
			- @OnClose 어노테이션을 통해 클라이언트 소켓이 접속을 종료 시 실행
				-> 클라이언트 소켓의 세션이 저장된 List 에 해당 세션 제거 로직 작성

	2. JS 내장 라이브러리  		=> 클라이언트 소켓
		[클라이언트 소켓 생성]
			- WebSocket 클래스를 이용한 클라이언트 소켓 생성
				-> let/const 객체명 = new WebSocket('서버소켓의 주소');	
				<속성> ★ 각 속성을 제공받고 각 속성에 어떤 로직을 실행할지 개발자가 구현
					1) .onmessage : 클라이언트 소켓이 메세지를 받았을 때 자동으로 실행되는 속성
						예] .onmessage = () => {메세지 받았을 때 실행 코드}
					2) .onopen    : 클라이언트 소켓이 서버 소켓과 접속 성공 시 자동으로 실행되는 속성
						예] .onopen = () => {접속 성공 시 실행 코드}
					3) .onclose   : 클라이언트 소켓이 서버 소켓과 접속 종료 시 자동으로 실행되는 속성
						예] .onclose = () => {접속 종료 시 실행 코드}
					4) .onerror   :  클라이언트 소켓이 서버 소켓과 접속 시도 시 오류가 발생하면 자동으로 실행되는 속성
						예] .onerror = () => {오류 발생 시 실행 코드}
				<메소드>
					1) .send() : 연결된 서버 소켓에게 메세지를 보낼 때 사용되는 함수(문자열만 가능하기 때문에 형변환 필요)		
		
		[클라이언트 소켓 -접속-> 서버 소켓]
			- 객체명.send("전송할 메세지(문자열)")
		
		[클라이언트 소켓 <-메세지전송- 서버 소켓]
			- 객체명.onmessage(실행 코드)
	
	★ 서버 소켓 => 1개
	★ 클라이언트 소켓 => N개
	★ 서버 소켓은 N 개의 클라이언트 소켓을 저장 / 관리
	예] user1 <-통신-> 서버 <-통신-> user2 => user1 과 user2 가 직접적으로 통신하지 않고 서버 소켓을 통해 통신함
	
	
	
	
	
	
	
	