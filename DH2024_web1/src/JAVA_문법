[제네릭 타입]
- 정의 : 여러 가지 타입에서 동작할 수 있도록 만든 문법
- 목적 : 클래스를 만들 때 변수 타입을 정하지 않고 인스턴스 생성 시 변수 타입 지정
		-> 다양한 타입의 데이터를 처리할 수 있다,
- 사용법 : < > 를 사용
	1. 클래스 정의
		1) 1 개의 제네릭 타입
			class 클래스명<제네릭타입명>{
				제네릭타입명 변수명;
			}
		2) 여러 개의 제네릭 타입
			class 클래스명<제네릭타입명1, 제네릭타입명2>{
				제네릭타입명 변수명;
			}
	2. 제네릭 타입을 이용한 인스턴스 생성
		1) 1 개의 제네릭 타입
			클래스명<사용할 타입명> 변수명 = new 생성자명<>();
		2) 여러 개의 제네릭 타입
			클래스명<사용할 타입명1, 사용할 타입명2> 변수명 = new 생성자명<>();
		
- 사용처 : 컬렉션프레임워크(ArrayList<> / HashMap() 등등)
- 특징
	1. 변수의 유연성
	2. 코드 중복 제거
	3. 잘못된 타입 방지		

[컬렉션 프레임워크]
- 수집(저장) 관련된 미리 만들어진 라이브러리를 제공
- 정의 : 자료를 수집/저장하는 방법을 미리 만들어둔 인테페이스/클래스(메소드) 의 집합소
- 목적 : 복잡한 자료구조를 제공받아 편리한 데이터 관리를 위함
	★ 자료구조 : 컴퓨터가 데이터를 저장하는 효율적인 방법 예] 큐 / 스택 / 트리 / 그래프 등등
- 컬렉션 인터페이스
	1. List 인터페이스
		1) 구현체 
			- 공통점 : 저장된 순서(인덱스)를 이용한 데이터 관리 / 데이터 중복 허용
			- ArrayList 클래스  : 
			- Vector 클래스     : 동기화된 메소드 제공 (멀티 스레드에서 주로 사용)
			- LinkedList 클래스 : 리스트 내 중간 삽입 / 삭제 시(ArrayList 보다 좋은 성능을 가짐) 사용
		2) 메소드
			- .add(자료) : 리스트 내에 지정한 자료를 마지막 요소에 추가
			- .set(인덱스, 자료) : 리스트 내 지정한 인덱스에 지정한 자료의 요소 변경
			- .get(인덱스) : 리스트 내 지정한 인덱스의 요소 값 반환
			- .size() : 리스트 내 요소 전체 개수 반환
			- .contains(자료) : 리스트 내 지정한 자료 존재 여부 반환(boolean)
			- .indexOf(자료) : 리스트 내 지정한 자료의 인덱스 반환 (없을 시 -1 반환)
			- .remove(인덱스 / 자료) : 리스트 내 지정한 인덱스/자료 삭제
			- .clear() : 리스트 내 모든 요소 삭제
			- .isEmpty() : 리스트 내 요소 존재 여부(boolean)
		★ 리스트 내 요소 순회 방법 ★
			1) 일반 for 문 사용
			2) 향상된 for 문 : for(타입 반복변수명 : 리스트명) { }
			3) .forEach() -> 람다식 : JS : () => { } / JAVA : () -> { }
	2. Set 인터페이스
		1) 구현체
			- 공통점 : 저장된 순서(인덱스)없이 각 요소를 주소값으로 비교하여 동일한 주소값을 가진 자료는 저장하지 않음 
					-> 중복 허용 X(자동 중복 제거)
					-> 인덱스를 사용하는 메소드 X
			- HashSet 클래스 : 
			- TreeSet 클래스 : 자동정렬	
		2) 메소드
			- .add() : Set 내 지정한 자료 추가
			- .size() : Set 내 전체 요소 개수 반환
			- .remove(자료) : Set 내 지정한 자료 존재 시 삭제
			- .contains(자료) : Set 내 지정한 자료가 존재하는 지 여부 반환(boolean)
			- .iterator() : Set 내 반복자 인터페이스 반환
				-> Set 컬렉션은 인덱스가 없기 때문에 인덱스를 통한 조회가 불가능하여 iterator 를 이용
				-> iterator 타입 
					1_ .hashNext() : 다음 요소가 존재 시 true / 존재하지 않을 시 false
					2_ .next() : 다음 요소 값 반환
		★ Set 내 요소 순회 ★
			- 인덱스가 존재하지 않기 때문에 일반 for 문으로 순회 불가
			1) 향상된 for 문	-> iterator 기반으로 만들어진 문법
			2) .forEach() -> iterator 기반으로 만들어진 문법
	3. Map 인터페이스
		1) 구현체 : 저장된 순서(인덱스) 없이 key 와 value 로 entry(한쌍)를 저장하는 구조
				-> key : 중복 불가
				-> value : 중복 가능
			- HasgMap 클래스
			- HashTable 클래스 
		2) 메소드
			- .put(key, value) : Map 내 key 와 value 를 entry(한쌍)으로 저장
			- .get(key) : Map 내 지정한 key 의 value 값 반환
			- .size() : Map 내 전체 entry 개수 반환
			- .remove(key) : Map 내 지정한 key 의 entry 삭제
			- .containsKey(key) : Map 내 지정한 Key 의 존재 여부 반환
			- .containsKey(value) : Map 내 지정한 value 의 존재 여부 반환
			- .entrySet() : Map 내 모든 entry 반환
			- .KeySet() : Map 내 모든 key 반환
			- .values() : Map 내 모든 value 반환
		★ Map 내 요소 순회 ★
			- 인덱스가 존재하지 않기 때문에 일반 for 문으로 순회 불가	
			1) 향상된 for 문 -> .KeySet()로 key 를 순회
			2) .forEach() -> .KeySet().forEach() 로 key 를 순회
- 인터페이스 
	-> 추상메소드 : 메소드를 선언만 하고 구현하지 않은 메소드
	-> 구현체 : 인터페이스를 구현한 객체 -> 클래스가 인터페이스를 implement 하여 추상메소드를 오버라이딩
	
	
	
	
	
	
	
	
	